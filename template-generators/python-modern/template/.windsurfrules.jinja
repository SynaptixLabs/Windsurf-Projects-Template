# Windsurf Project Rules for {{ project_name }}

## Project Context
This is a {{ project_type.replace("-", " ") }} project using modern 2025 Python tooling. The project follows src layout pattern and emphasizes code quality, testing, and maintainability.

{% if project_type == "agentic-ai" -%}
## Agentic AI Specific Guidelines
- **Framework**: CrewAI for multi-agent orchestration
- **Agent Design**: Role-based agents with clear responsibilities
- **State Management**: Use Pydantic models for agent state
- **Tool Integration**: Custom tools for external integrations
- **Memory**: Implement short-term, long-term, and entity memory
- **Flows vs Crews**: Use Flows for deterministic processes, Crews for autonomous collaboration

{% elif project_type == "web-api" -%}
## Web API Specific Guidelines
- **Framework**: FastAPI with async/await patterns
- **Request/Response**: Pydantic models for all API contracts
- **Database**: Async database operations with proper connection pooling
- **Authentication**: Implement proper auth and authorization
- **Documentation**: Auto-generated OpenAPI/Swagger documentation
- **Error Handling**: Structured error responses with proper HTTP status codes

{% elif project_type == "data-science" -%}
## Data Science Specific Guidelines
- **Data Processing**: Polars for high-performance data manipulation
- **Pipeline**: {{ orchestration_tool | title }} for workflow orchestration
- **Storage**: Efficient data formats (Parquet, Arrow)
- **Analysis**: DuckDB for analytical queries
- **Validation**: Pydantic for data schema validation
{% if include_notebooks -%}
- **Notebooks**: Keep notebooks clean and reproducible
{% endif -%}

{% elif project_type == "game-development" -%}
## Game Development Specific Guidelines
- **Engine**: Pygame for 2D graphics and game loop
- **State Management**: Clear game state with Pydantic models
- **Performance**: 60 FPS target, optimize critical paths
- **Input Handling**: Responsive user input with proper event handling
- **Audio**: Efficient sound loading and playback
- **Testing**: Unit tests for game logic, integration tests for gameplay

{% endif -%}

## Code Style & Standards
- **Python Version**: {{ python_version }}+ with type hints everywhere
- **Linting**: Use Ruff for all linting and formatting (replaces Black, isort, flake8)
- **Testing**: pytest with coverage ≥{{ coverage_threshold }}%, include unit and integration tests
- **Documentation**: Clear docstrings for all public functions/classes
- **Imports**: Use absolute imports, group by standard/third-party/local

## Architecture Patterns
- **Separation of Concerns**: Clear separation between business logic, data, and presentation
- **Pydantic Models**: Use for all data validation and configuration
{% if project_type == "web-api" or project_type == "agentic-ai" -%}
- **Async Support**: Prefer async/await for I/O operations
{% endif -%}
- **Error Handling**: Explicit error handling with custom exceptions
- **Logging**: Use structlog for structured logging

## File Organization
```
src/{{ project_slug.replace('-', '_') }}/
{% if project_type == "agentic-ai" -%}
├── agents/        # CrewAI agents and crews
├── tools/         # Custom tools for agents
├── flows/         # CrewAI flows for structured processes
├── api/           # FastAPI endpoints (if applicable)
├── models/        # Pydantic data models
├── config/        # Configuration management
└── main.py        # Entry point
{% elif project_type == "web-api" -%}
├── api/           # FastAPI route definitions
├── core/          # Business logic
├── models/        # Pydantic data models
├── services/      # Business services
{% if include_auth -%}
├── auth/          # Authentication logic
{% endif -%}
{% if databases -%}
├── database/      # Database models and connections
{% endif -%}
└── main.py        # FastAPI application
{% elif project_type == "data-science" -%}
├── data/          # Data processing modules
├── analysis/      # Analysis and modeling
├── pipelines/     # {{ orchestration_tool | title }} workflows
├── models/        # Data models and schemas
├── utils/         # Utility functions
{% if include_notebooks -%}
├── notebooks/     # Jupyter notebooks
{% endif -%}
└── main.py        # Entry point
{% elif project_type == "game-development" -%}
├── core/          # Core game logic
├── ui/            # User interface components  
├── models/        # Game data models
{% if include_assets -%}
├── assets/        # Game assets (images, sounds)
{% endif -%}
├── utils/         # Utility functions
└── main.py        # Game entry point
{% else -%}
├── core/          # Core application logic
├── models/        # Pydantic data models
├── utils/         # Utility functions
└── main.py        # Entry point
{% endif -%}
```

## Testing Strategy
- **Unit Tests**: For all core business logic
{% if project_type == "web-api" -%}
- **API Tests**: Test all endpoints with various scenarios
- **Integration Tests**: Test database interactions and external services
{% elif project_type == "agentic-ai" -%}
- **Agent Tests**: Test individual agent behaviors
- **Integration Tests**: Test crew interactions and workflows
- **Tool Tests**: Validate custom tool functionality
{% elif project_type == "data-science" -%}
- **Data Tests**: Validate data transformations and quality
- **Pipeline Tests**: Test workflow execution
- **Model Tests**: Validate analysis and modeling logic
{% elif project_type == "game-development" -%}
- **Game Logic Tests**: Test rules and game mechanics
- **UI Tests**: Test user interface components
- **Performance Tests**: Benchmark critical game operations
{% endif -%}
{% if testing_framework == "comprehensive" or testing_framework == "enterprise" -%}
- **Property-Based Testing**: Use Hypothesis for complex validation
- **Integration Testing**: Use testcontainers for realistic environments
{% endif -%}

## Code Generation Guidelines
- Always include comprehensive type hints
- Generate tests alongside code
- Include error handling and logging
- Follow the established project structure
- Use Pydantic for configuration and data models
{% if project_type == "web-api" or project_type == "agentic-ai" -%}
- Implement proper async patterns where applicable
{% endif -%}

## Sprint Planning
- Focus on incremental feature delivery
- Maintain test coverage throughout development
- Document architectural decisions
- Regular code quality checks via CI/CD

## Dependencies Management
{% if package_manager == "uv" -%}
- Use UV for ultra-fast dependency management (80x faster than pip)
- Pin exact versions for reproducible builds
{% else -%}
- Use Poetry for dependency management
- Pin exact versions for reproducible builds
{% endif -%}
- Separate dev dependencies from runtime
- Regular security updates via automated tools

{% if databases -%}
## Database Guidelines
{% for db in databases -%}
{% if db == "postgresql" -%}
- **PostgreSQL**: Use asyncpg with SQLAlchemy for async operations
{% elif db == "mongodb" -%}
- **MongoDB**: Use Motor for async MongoDB operations
{% elif db == "redis" -%}
- **Redis**: Use redis-py with hiredis for performance
{% elif db == "chromadb" -%}
- **ChromaDB**: Vector database for embeddings and semantic search
{% elif db == "pinecone" -%}
- **Pinecone**: Managed vector database for large-scale embeddings
{% endif -%}
{% endfor -%}
- Always use connection pooling and proper connection management
- Implement proper error handling and retries
- Use transactions where appropriate
{% endif -%}
